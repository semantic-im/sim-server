/*
 * Copyright 2010 Softgress - http://www.softgress.com/
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package sim.server.storage;

import java.util.concurrent.ConcurrentLinkedQueue;

import org.ontoware.rdf2go.RDF2Go;
import org.openrdf.rdf2go.RepositoryModelFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import sim.data.Metrics;
import sim.server.RdfDatabase;
import sim.server.RrdDatabase;

/**
 * Thread safe class used to collect all the events/measurements generated by
 * instrumented code.
 * Maps the java object to semantic concepts, uploads to semantic and RRD
 * database.
 * 
 * @author mcq
 * 
 */
public class StorageWriter {
	private static ConcurrentLinkedQueue<Metrics> measurements = new ConcurrentLinkedQueue<Metrics>();

	public static StorageComunicator thread;
	
	static {
		RDF2Go.register(new RepositoryModelFactory());
		
		thread = new StorageComunicator();
		thread.start();		
	}
	
	public static void addMeasurement(Metrics measurement) {
		measurements.add(measurement);
	}

	private static class StorageComunicator extends Thread {
		
		private static final Logger logger = LoggerFactory.getLogger(StorageComunicator.class);
		
		private static final long COLLECT_INTERVAL = 5000;
		private static final int MAX_METRICS_WRITE = 10000;

		private RdfDatabase rdfWriter = new RdfDatabase();
		private RrdDatabase rrdWriter = new RrdDatabase();
		
		public StorageComunicator() {
			super("SIM - StorageCommunicator");
			setDaemon(true);
		}

		@Override
		public void run() {
			while (true) {
				try {
					sleep(COLLECT_INTERVAL);
				} catch (InterruptedException e) {
					break;
				}
				try {
					rdfWriter.open();
					sendMeasurements();
					rdfWriter.close();
				} catch (Exception e) {
					logger.error("unknown error, ignore to heep thread running", e);
				}
			}
		}

		private void sendMeasurements() {
			if (measurements.isEmpty())
				return;
			
			int count = 0;
			while (!measurements.isEmpty()) {
				Metrics metrics = measurements.remove();
		
				metrics.accept(rdfWriter);
				metrics.accept(rrdWriter);
				
				count++;
				if (count >= MAX_METRICS_WRITE)
					break;
			}
		}
		
	}
}
